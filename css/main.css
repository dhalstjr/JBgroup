@charset 'utf-8';

/* 반응형할 때 유용한 기능들 */
/* aspect-ratio 가로세로 비율을 맞출 때 사용되고, 특히 이미지나 비디오에 사용된다. */

/* header 영역부터 실시 */
#header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  /* bottom까지 0으로 설정하면 뷰포트 전체가 fixed가 된다. */
  /* 어떤 이유때문인가 했더니 fixed는 뷰포트를 기준으로 고정을 시키는 CSS이다. -> 스크롤 해도 항상 그 자리에 고정. */
  /* bottom까지 0으로 설정한다면, top부터 bottom까지 모두 고정이 되기 때문에 결과적으로 세로 높이가 전체 뷰포트 높이 전체가 된다. */
  /* top만 0으로 설정하면 뷰포트 위에서부터 고정되고, 좌우도 0으로 설정해 고정되어있기 때문에 자식 높이까지만 높이를 가지는  */
  /* top을 제거하고 bottom만 0으로 설정하면 뷰포트 맨 아래에서 부터 고정이 된다. */

  z-index: 999;

  background: #f5f;

  color: #fff;
}

#header .site-header {
  position: relative;

  /* 높이를 주고 grid를 이용해여 align-items : center를 주면 중앙 정렬이 되기 때문에 grid를 사용한 것으로 보인다. */
  /* 굳이 site-header라는 html구조를 더 기입해서 grid을 이용해서 중앙정렬을 실시한 이유는 -> 정렬 계층을 나누어서 레이아웃을 더 유연하게 만드려는 전략으로 보인다. */
  /* 전체 구조용 grid , 내부 정렬용 flex */
  height: 9.8rem;
  align-items: center;
  display: grid;
}

.header-container {
  padding: 0 6.4rem;
}

#header .header-content {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

#header .header-content .logo-box {
  width: 16rem;
  height: 2.6rem;
}

#header .header-content .logo-box .logo {
  display: block;
  width: 100%;
  height: 100%;

  background: url(../img/brand-logo.png) no-repeat 0 0 / contain;
}

#header .header-content #nav .gnb {
  display: flex;
  align-items: center;
  justify-content: space-between;

  text-align: center;
}

#header .header-content #nav .gnb > li {
  position: relative;

  /* li에게 패딩을 주기 -> 보니까 서브메뉴의 디자인때문에 주는 것 같음*/
  padding: 0 1rem;
}

#header .header-content #nav .gnb > li > a {
  /* 크기 주기 */
  display: block;
  font-size: 1.8rem;
  line-height: 1.4;
  font-weight: 800;

  /* 크기를 주고 가운데 정렬 */
  display: flex;
  align-items: center;
  justify-content: center;

  /* px값을 vw으로 변환하려면 px값에 100울 곱하고 화면 너비를 나누면 된다.  */
  /* 500px화면에서 100px을 vw로 변환하려면 , 100px * 100 / 500px를 계산하면 된다. 결과 값은 20vw */

  /* 최소 높이 설정하는 명령이지만 clamp의 기능의 설명 */
  /* 반응형 웹디자인에서 사용되는 기법으로, clamp(min, preferred , max) 함수는 저 세가지 값을 기준으로 반응형 크기 범위를 제한하는 함수이다. */
  /* 처음은 최소값 , 두번째는 기준값 또는 선호값 , 세번째는 최대값으로 설정된다. */
  /* 이 코드를 해석하자면 9.6vw(뷰포트)너비에 따라 min-width가 유동적으로 바뀌지만, 8.89rem(최소값)보다 작아지지 않고, 16rem(최대값)보다 커지지 않도록 제한해줘. 라는 코드이다.  */
  /* 기준값을 설정하고, 그에 맞게 유동적으로 설정하기 위해서 이를 사용한다. */
  /* 미디어쿼리없이 반응형 디자인을 사용하기 위해서 사용, min(), max() 함수와 같은 반응형 디자인 CSS이다. */
  /* 주의할 점은 다른 단위를 사용하는 경우에만 사용 가능하다고 한다.( ex) min(20rem ,10vh) ) */
  /* vw(뷰포트 너비) -> 1vw는 화면 너비의 1%에 해덩합니다. 만약 뷰포트 1000px이면 100px이 10vw이다. */
  min-width: clamp(8.89rem, 9.6vw, 16rem);
  height: 9.8rem;
}

/* 유틸메뉴 */
#header .header-content .utils {
  display: flex;
  align-items: center;
  gap: 2.8rem;
}

#header .header-content .utils .family-btn {
  display: flex;
  align-items: center;
  justify-content: center;

  width: 7.8rem;
  height: 2.8rem;

  border-radius: 1.4rem;
  background: rgba(255, 255, 255, 0.15);

  font-weight: 800;
  font-size: 1.6rem;
  color: #fff;

  transition: background 150ms ease-in-out;
}

#header .header-content .utils .family-btn:hover {
  background: #00134a;
}

#header .header-content .utils .langs {
  display: flex;
  align-items: center;
  gap: 1rem;

  color: #fff;
  font-size: 1.4rem;
  font-weight: 800;
}

/* 구분선 */
#header .header-content .utils .langs .split {
  width: 1px;
  height: 14px;

  background: #fff;
  opacity: 0.3;
}

/* 유틸메뉴의 탭메뉴 아이콘 -> background가 아닌 크기를 줘서 만든 것 같음 */
#header .header-content .utils .site-tab {
  font-size: 0;
}

/* a태그에 가상요소를 추가헤서 크기와 높이를 주어 선처럼 만들기 */
#header .header-content .utils .site-tab .tab-menu {
  display: flex;
  align-items: center;
  justify-content: center;

  /* 사이트 탭메뉴가 들어갈 공간 */
  width: 2.2rem;
  height: 2.2rem;

  /* 텍스트를 화면 밖으로 보내서 안보이게 하려고 */
  text-indent: -999rem;
  overflow: hidden;

  position: relative;

  /* align-center가 안맞음. 혹시 몰라서 font-size : 0을 설정했지만, 틀어지는 건 아직 같음. */
  font-size: 0;
}

#header .header-content .utils .site-tab .tab-menu:before {
  content: "";
  display: block;
  width: 2.2rem;
  height: 0.2rem;
  background-color: #fff;

  /* 정중앙을 정렬하고 margin-top을 이용하여 조정. margin-top값이 없으면 서로 같은 위치에 겹쳐있음. -> 그러니 정중앙 정렬을 건들지 않고 margin-top을 서로 사용해 위치를 맞춤 */
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);

  /* align 센터에 맞추기 위해서 margin-top을 before와 after를 같이 줌. 반대로 */
  margin-top: -3px;

  transition: margin 300ms ease-in-out, transform 300ms ease-in-out;
}

#header .header-content .utils .site-tab .tab-menu:after {
  content: "";
  display: block;
  width: 2.2rem;
  height: 0.2rem;
  background-color: #fff;

  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);

  /* align 센터에 맞추기 위해서 margin-top을 before와 after를 같이 줌. 반대로 */
  margin-top: 3px;

  transition: margin 300ms ease-in-out, transform 300ms ease-in-out;
}

/* header : end */

/* main : start -> section1  */
#main {
  /* 100vh까지 사용한 이유는 브라우저 지원 떄문에 */
  min-height: 100vh;
  /* 100svh -> svh(small viewport height)란 최신 CSS 단위 중 하나로, 모바일에서의 "화면 높이 문제"를 해결하기 위해 등장한 기능이다. */
  /* 실제 콘텐츠를 가릴 수 있는 브라우저 UI(주소창, 툴바 등)를 고려한 최소 높이를 기준으로 하는 단위이다. */
  /* svh를 사용한 이유는 100vh에 있음 -> 100vh는 주소창을 포함한 높이. -> 모바일 브라우저(예 : Safari, Chrome 모바일)는 화면 상단에 주소창/탭 바 등 UI가 자동 숨김/등장한다. 그런데 100vh는 그 UI까지 포함한 높이로 계산합니다. */
  /* 결과, 주소창이 나타나면 콘텐츠가 짤리거나 스크롤 오류가 발생할 수 있다. */
  /* 그러하여 100svh를 사용하는 이유는 주소창이 보이는 상태에서도 콘텐츠가 짤리지 않기 위함이고,  */
  /* 특히 모바일 웹 앱 ,풀스크린 섹션, 히어로 영역(비주얼)에 많이 사용된다. */
  /* 모바일 UX 최적화에 매우 중요한 최신 CSS입니다. */
  min-height: 100svh;

  background: #55f;
}
/* main : end -> section1  */

#main .section1 {
  position: relative;
  z-index: 10;

  min-width: 100vw;
  min-height: 100lvh;
}

/* 비주얼 영역 화면 -> 비디오를 구할 수 없어 background로 설정 */
#main .visual {
  position: relative;
}

#main .section1 .visual .visual-bg {
  position: absolute;
  /* 위에서부터 시작 */
  top: 0;
  left: 0;
  right: 0;

  display: block;

  width: 100%;
  /* 100lvh는 large viewport height -> 주소창, 툴 바등이 보이는 전체 높이*/
  /* 내부 섹션에 100lvh를 사용한 이유는 회면이 최대로 높을 때 기준으로 디자인을 꽉 차게 유지하기 위해서.  */
  /* 반대로 전체 섹션의 100svh를 준 이유는 짤리는 것을 방지하기 위해서임. */
  /* 그래서 이 둘을 같이 사용하면 모바일 대응이 훨씬 안정적임. */
  /* 주소창이 사라져도 비주얼 영역이 꽉 차게 하기 위해서임. */
  height: 100lvh;
  background: url(../img/main-visual-bg.png) no-repeat 0 0 / cover;
  object-fit: cover;
}

#main .main-section-inner {
  /* 이게 부모 기준이 되어줘야 main-container가 보인다. */
  position: relative;
}

/*  */
#main .main-section-inner .main-container {
  /* padding: 0 17.8rem; */

  /* 최대 넓이 설정. */
  max-width: 156.4rem;

  margin: 0 auto;
  width: 100%;

  box-sizing: border-box;
}

#main .main-section-inner .main-container .grid-area {
  display: grid;

  grid-template-columns: 1fr 56%;

  gap: min(2.2vw, 64px);

  justify-content: space-between;

  /* header 높이를 padding을 줘 높이를 맞췀 */
  padding: 9.8rem 0;

  color: #fff;
}

/* grid 왼쪽 부분 */
#main .main-section-inner .main-container .grid-area .grid-left {
  display: grid;
  align-items: center;

  width: 100%;
  /* 애한테 크기를 줌 -> 본페이지에서는 calc로 중간을 맞춘 것 같음 */
  position: sticky;
  /* sticky를 주고 top은 고정되는 시점을 말하는 것 같다. */
  top: 0;

  /* height : calc(100svh와 상하 패딩을 준 것을 넣어 가운데 정렬) -> 나는 상하 패딩 9.8rem으로 줬으니 그걸 뺴야함*/
  height: 100svh;
  height: calc(100svh - 9.8rem - 9.8rem);
}

#main
  .main-section-inner
  .main-container
  .grid-area
  .grid-left
  .grid-left-container {
  display: flex;

  flex-direction: column;
  gap: 6.4rem;
  max-width: 34.9rem;
}

#main .main-section-inner .main-container .grid-area .grid-left .title {
  font-size: 8.8rem;
  font-weight: 800;
  color: #fff;

  /* 글 간격, 높이 맞추기 */
  letter-spacing: -0.02em;
  line-height: 1.1;

  word-break: keep-all;

  /* 첫문자를 대문자로 변환 */
  text-transform: capitalize;
}

#main
  .main-section-inner
  .main-container
  .grid-area
  .grid-left
  .video-container {
  display: flex;
  align-items: center;
  justify-content: space-between;

  max-width: 32rem;

  gap: 1.6rem;
}

#main
  .main-section-inner
  .main-container
  .grid-area
  .grid-left
  .video-container
  .progress {
  display: block;
  width: 100%;
  height: 8px;

  border-radius: 0.4rem;

  background: rgba(255, 255, 255, 0.2);
}

/* 영상 길이만큼 채워지는 효과 바 */
#main
  .main-section-inner
  .main-container
  .grid-area
  .grid-left
  .video-container
  .progress
  .bar {
  display: block;
  width: 50%;
  height: 8px;

  border-radius: 0.4rem;

  background: rgba(255, 255, 255, 1);
}

#main
  .main-section-inner
  .main-container
  .grid-area
  .grid-left
  .video-container
  .toggle-play-btn {
  box-sizing: border-box;

  display: flex;
  align-items: center;
  justify-content: center;
  width: 4.2rem;
  height: 3.4rem;

  background: url(../img/toggle-btn-play.svg) no-repeat 0 0 / contain;
}

/* grid 오른쪽 부분 */
#main .main-section-inner .main-container .grid-area .grid-right {
  display: flex;
  align-items: center;
}

#main .main-section-inner .main-container .grid-area .grid-right .widgets {
  display: grid;

  /* 1fr 50%와 완전히 다른 것임  */
  /* 1fr 1fr은 남은 공간을 1 : 1 비율로 나눈다는 것, 전체 너비가 만약에 1000px 이라면 500px씩 나눠갖는 것이고, */
  /* 1fr 50%은 첫번째 열은 남는 공간 중 일부를 차지하고, 두번째 열은 항상 전체 너비의 50%를 고정으로 갖게 됨. */
  /* 그러니까 50%로 설정하면 두번째 열은 무조건 50%를 차지해야함, 1fr로 설정하면 앞에 1fr이 아닌 1.51351156fr 이런식으로 자신보다 큰 수가 들어오면 차지하는 비율이 줄어든다. */
  grid-template-columns: 1.384fr 1fr;

  gap: 1.6rem;

  margin-left: auto;

  /* 최대 크기 설정 */
  max-width: 66.4rem;
}

#main .main-section-inner .main-container .grid-area .grid-right .widgets .col {
  /*  grid 설정으로 생긴 열을 grid로 설정하여 gap을 설정 */
  display: grid;

  gap: 1.6rem;
}

/* 위젯 크기 */
/* 첫 위젯 */
#main .widget {
  display: flex;
  flex-direction: column;

  border-radius: 4.4rem;
  padding: 2.8rem;

  background: rgba(0, 19, 74, 0.48);
}

#main
  .main-section-inner
  .main-container
  .grid-area
  .grid-right
  .widgets
  .widget
  .widget-title {
  font-size: 1.8rem;
  font-weight: 900;
  color: #fff;
  line-height: 1;
  letter-spacing: -0.02em;

  margin-bottom: 2.4rem;

  display: flex;
  align-items: center;

  gap: 0.6rem;
}

#main
  .main-section-inner
  .main-container
  .grid-area
  .grid-right
  .widgets
  .widget
  .widget-title:before {
  content: "";
  display: block;

  width: 1rem;
  height: 1rem;

  background: #fff;
  border-radius: 0.6rem;
}

#main
  .main-section-inner
  .main-container
  .grid-area
  .grid-right
  .widgets
  .widget
  .valuation {
  font-size: 0;
  line-height: 1.4rem;
  text-align: center;
}

#main
  .main-section-inner
  .main-container
  .grid-area
  .grid-right
  .widgets
  .widget
  .valuation
  > ul {
  display: flex;
  justify-content: space-between;
  gap: 0.8rem;
}

#main
  .main-section-inner
  .main-container
  .grid-area
  .grid-right
  .widgets
  .widget
  .valuation
  > ul
  > li {
  display: flex;
  flex-direction: column;
  align-items: center;

  /* 크기를 줘서 이미지에 줬던 margin이 틀어지지 않게 해봄 */
  /* 본페이지에는 flex : 1를 줘서 사용함 -> 크기를 주는 것과 다른 점은 flex : 1은 남는 공간을 다른 형제들과 1 : 1 비율로 나눠가지겠다는 의미이다. 예를 들어 3개의 li가 있으면 33.333%의 비율로 나눠가지겠다는 의미가 돤다.*/
  /* flex : 1은 반응형을 구현할 때 좋다. 최소 크기를 주어 맞추게 된다면, 크기가 줄어들었을 때 틀어질 수도 있다. 그러니 미디어쿼리를 이용해 크기를 다시 조절해줘야한다. */
  /* flex를 사용하면 미디어쿼리를 사용하지 않고, 비율을 유지하는 데 가능하다는 것이다.  */
  /* flex 말고 다양한 방법이 많다. 너무 flex의 의존하지 말자. ul에 grid를 줘서 사용할 수 있다.  */
  /* 본페이지와는 달라서 flex : 1만 주면 텍스트가 틀어지기 때문에 최소 크기를 주고 , flex : 1를 사용하겠다.  */
  flex: 1;
  min-width: 10.6rem;
}

/* img의 크기를 정해주고 비율을 맞춘다. */
#main
  .main-section-inner
  .main-container
  .grid-area
  .grid-right
  .widgets
  .widget
  .valuation
  > ul
  > li
  > img {
  display: block;
  width: 8.2rem;

  /* aspect-ratio 속성은 주로 반응형 웹페이지에서 화면 비율을 유지하면서 컨텐츠를 렌더링할 때 사용된다. 특히 비디오나 이미지와 같이 가로세로 비율이 고정되어야하는 요소들을 사용할 떄 유용 */
  /* aspect-ratio 1 / 1 는 가로세로 비율을 1:1 즉, 정사각형을 의미한다. -> 1/1로 설정한다면 정사각형으로 설정하는 것이다.  */
  aspect-ratio: 1 / 1;

  background: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 4rem;

  /* margin 0 auto 다음에 나오는 것은 밑에 부분에 margin을 주는 것이다. */
  margin: 0 auto 1rem;
}

#main
  .main-section-inner
  .main-container
  .grid-area
  .grid-right
  .widgets
  .widget
  .valuation
  > ul
  > li
  > span {
  display: block;
  font-weight: 800;
  font-size: 1.6rem;

  letter-spacing: -0.04em;
}

/* 두번째 위젯 */

#main .widgets .ir-calender .presentation > ul {
  display: flex;
  flex-direction: column;
}

#main .widgets .ir-calender .presentation > ul > li {
  padding: 1.4rem 0;

  border-bottom: 1px solid rgba(255, 255, 255, 0.25);
}

/* li 처음 요소 위 패딩 사라지게 */
#main .widgets .ir-calender .presentation > ul > li:first-of-type {
  padding: 0 0 1.4rem 0;
}

/* li 마지막 border 사리지게 */
#main .widgets .ir-calender .presentation > ul > li:last-of-type {
  border-bottom: none;
}

#main .widgets .ir-calender .presentation > ul > li > a {
  display: block;
  width: 100%;
  height: 100%;

  font-weight: 700;
  color: #fff;

  letter-spacing: -0.04em;
  word-break: keep-all;
}

#main .widgets .ir-calender .presentation > ul > li > a > h4 {
  font-size: 1.7rem;
  line-height: 1.4;
  margin-bottom: 0.6rem;
}

#main .widgets .ir-calender .presentation > ul > li > a > span {
  display: block;
  color: rgba(255, 255, 255, 0.6);
  font-size: 1.4rem;
}

/* 세번쨰 위젯 */

#main .widgets .report .report-content {
  display: flex;
  flex-direction: column;
}

#main .widgets .report .report-content .report-name {
  font-size: 2.4rem;
  font-weight: 700;
  word-break: keep-all;

  letter-spacing: -0.04em;
  line-height: 1.4;

  padding: 0 0 1.2rem 0;

  border-bottom: 1px solid rgba(255, 255, 255, 0.25);
}

#main .widgets .report .report-content .move-btn {
  margin-top: 1.2rem;
}

#main .widgets .report .report-content .move-btn a {
  width: 3.6rem;
  height: 3.6rem;
  background: rgba(255, 255, 255, 0.2);

  border-radius: 50%;

  display: flex;
  align-items: center;
  justify-content: center;

  transition: background 250ms ease-in-out;
}

#main .widgets .report .report-content .move-btn a:hover {
  background: rgba(255, 255, 255, 1);
}

#main .widgets .report .report-content .move-btn a:before {
  content: "";

  display: block;
  width: 1.4rem;
  height: 1.4rem;

  background: url(../img/widget-arrow.svg) no-repeat 0 0 / contain;

  transition: background 250ms ease-in-out;
}

#main .widgets .report .report-content .move-btn a:hover:before {
  background: url(../img/widget-arrow-hover.svg) no-repeat 0 0 / contain;
}

/* 네번째 위젯 */

#main .result {
  background: rgba(25, 228, 238, 0.4);
}
#main .result .result-content {
}

#main .result .result-content .result-name {
  font-size: 2.4rem;
  font-weight: 700;
  word-break: keep-all;

  letter-spacing: -0.04em;
  line-height: 1.4;

  padding: 0 0 1.2rem 0;

  border-bottom: 1px solid rgba(255, 255, 255, 0.25);
}

#main .result .result-list {
  display: flex;
  flex-direction: column;

  gap: 1.6rem;
  margin-top: 1.2rem;
}

#main .result .result-list > li {
}

#main .result .result-list > li > a {
  display: flex;
  align-items: center;
  justify-content: space-between;

  color: #fff;
}

#main .result .result-list > li > a > h4 {
  font-size: 1.7rem;
  font-weight: 700;

  letter-spacing: -0.04em;
}

#main .result .result-list > li > a > .download-btn {
  display: block;
  display: flex;
  align-items: center;
  justify-content: center;

  width: 3.6rem;
  height: 3.6rem;

  background: rgba(255, 255, 255, 0.2);
  border-radius: 50%;

  transition: background 250ms ease-in-out;
}

#main .result .result-list > li > a > .download-btn:hover {
  background: #fff;
}

#main .result .result-list > li > a > .download-btn:before {
  content: "";
  display: block;
  width: 1.2rem;
  height: 1.6rem;

  background: url(../img/download-btn.svg) no-repeat 0 0 / contain;

  transition: background 250ms ease-in-out;
}

#main .result .result-list > li > a > .download-btn:hover:before {
  background: url(../img/download-btn-hover.svg) no-repeat 0 0 / contain;
}

/* 다섯번쨰 위젯 */

#main .stock-info {
  background: rgba(255, 255, 255, 0.75);
  color: #333;
}

#main
  .main-section-inner
  .main-container
  .grid-area
  .grid-right
  .widgets
  .stock-info
  .widget-title:before {
  background: #0a31a8;
}

#main
  .main-section-inner
  .main-container
  .grid-area
  .grid-right
  .widgets
  .stock-info
  .widget-title {
  color: #333;
}

#main .stock-info .stock-info-content {
}

#main .stock-info .stock-info-content .jb {
}

#main .stock-info .stock-info-content .jb .jb-title {
  font-size: 1.4rem;
  font-weight: 700;

  letter-spacing: -0.02em;

  margin-bottom: 1rem;
}

#main .stock-info .stock-info-content .jb .jb-money-content {
  display: flex;
  flex-direction: column;

  gap: 1.6rem;

  padding-bottom: 2.8rem;

  border-bottom: 1px solid rgba(0, 0, 0, 0.15);
}

#main .stock-info .stock-info-content .jb .jb-money-content .jb-money {
  margin-left: auto;
  vertical-align: baseline;
}

#main .stock-info .stock-info-content .jb .jb-money-content .jb-money span {
  display: inline-block;
  font-size: 2rem;
  font-weight: 700;

  transform: translateY(126%);
}

#main .stock-info .jb .jb-money-content .jb-money strong {
  display: inline-block;
  font-size: 4.8rem;
  font-weight: 800;
  letter-spacing: -0.04em;

  margin-right: 0.6rem;
}

#main .stock-info .stock-info-content .jb .jb-money-content .jb-money-quote {
  margin-left: auto;
}

#main
  .stock-info
  .stock-info-content
  .jb
  .jb-money-content
  .jb-money-quote
  span {
  display: inline-block;

  font-size: 1.4rem;
  font-weight: 500;

  margin-right: 0.6rem;
}

#main
  .stock-info
  .stock-info-content
  .jb
  .jb-money-content
  .jb-money-quote
  strong {
  color: #f00;

  font-size: 1.4rem;
  font-weight: 500;
}

#main .kos-container {
  display: flex;
  flex-direction: column;

  margin-top: 2.8rem;

  gap: 1.6rem;
}

#main .kos-container .kospi .kospi-content,
#main .kos-container .kosdaq .kosdaq-content {
  display: flex;
  justify-content: space-between;
}

#main .kos-container .title {
  font-size: 1.4rem;
  font-weight: 500;

  letter-spacing: -0.02em;
}

#main .kos-container .krx {
  margin-left: auto;

  text-align: right;
  display: flex;
  flex-direction: column;
  gap: 0.6rem;
}
#main .kos-container .krx .krx-num {
  font-size: 1.4rem;
  font-weight: 500;
  letter-spacing: -0.06em;
}

#main .kos-container .krx .krx-change {
  font-size: 1.4rem;
  font-weight: 500;
  letter-spacing: -0.04em;
  color: #1850ff;
}

/*  section2 CSS - start */

/* 최소 높이 바꿔야 함 */
/* #main .section2 {
  position: relative;
  z-index: 10;

  min-width: 100vw;
  높이가 자꾸 틀어짐. 배경할 때 다시 설정.
  min-height: 92rem;

  background: #f55;
} */

#main .section2 .visual {
  position: relative;
  height: 0;
}

/* section2 영역은 이미지를 세개 배치해서 배경을 설정 -> 이건 나중에 설정 */
/* #main .section2 .visual .visual-bg {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;

  display: block;

  background: url(../img/main-visual-bg2.png) no-repeat 0 0 / cover;
  width: 100%;
  height: 100lvh;

  overflow: hidden;
} */

/* section2 visual 배경화면 부분 이미지 세개 넣고 다시 설정. */

.section2 {
  position: relative;
  z-index: 1;

  /* .section2에 background 컬러를 넣어줘서 배경색을 고정시킴 */
  background-color: #0d2d77;
}

.section2 .visual .visual-bg {
  position: absolute;
  background: 50% 50% no-repeat;
  background-size: cover;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;

  /* top을 따로 설정해줘야  */
  top: -6.3rem;
  bottom: auto;

  /* 높이 조절 */
  height: calc(100vh + 9.8rem);

  overflow: hidden;

  background-color: #0d2d77;
}

/* active 클래스 지정 */
.section2 .visual .visual-bg.active .bg-item1 {
  transform: rotate(0);

  top: -29.7rem;
  left: -44.5rem;
}

.section2 .visual .visual-bg.active .bg-item2 {
  transform: rotate(0);

  top: 47.9rem;
  left: -14.6rem;
}

.section2 .visual .visual-bg.active .bg-item3 {
  transform: rotate(0);

  top: 25.8rem;
  right: -47.9rem;
}

/* 이미지 크기 및 위치 선정.  */
.section2 .visual .visual-bg .bg-item1 {
  width: 104.7rem;

  /* 절대 요소를 줘서 배경에 맞게 설정해야 함  */
  position: absolute;

  /* top과 left, right 설정 */
  top: -29.7rem;
  left: -44.5rem;

  transition: 1.2s ease-in-out;
  transition-property: transform, top left right;

  /* 로테이트 설정 */
}

.section2 .visual .visual-bg .bg-item2 {
  width: 92.2rem;

  /* 절대 요소를 줘서 배경에 맞게 설정해야 함  */
  position: absolute;

  /* top과 left, right 설정 */
  top: 47.9rem;
  left: -14.6rem;

  transition: 1.2s ease-in-out;
  transition-property: transform, top left right;

  /* 로테이트 설정 */
}

.section2 .visual .visual-bg .bg-item3 {
  width: 91.3rem;

  /* 절대 요소를 줘서 배경에 맞게 설정해야 함  */
  position: absolute;

  /* top과 left, right 설정 */
  top: 25.8rem;
  right: -47.9rem;

  transition: 1.2s ease-in-out;
  transition-property: transform, top left right;

  /* 로테이트 설정 */
}

.section2 .visual .visual-bg img {
  display: block;
  width: 100%;
}

/* grid-left 부분 설정 다르게 해야함.  */
#main .main-section-inner .main-container .grid-area .grid-left.sec1-exclusion {
  /* 포지션 static으로 다시 설정. -> 텍스트 자리를 다시 잡기 위해사 */
  position: static;
  align-items: start;
}

#main
  .main-section-inner
  .main-container
  .grid-area
  .grid-left.sec1-exclusion
  .grid-left-container {
  /* 텍스트 사이 간격 다시 설정 */
  gap: 2.4rem;

  /* 텍스트 길이를 위해 최대 넓이 다시 설정 */
  max-width: 60rem;
}

#main-section .section-title {
  font-weight: 800;
  font-size: 3.8rem;

  color: #fff;

  letter-spacing: -0.02em;

  display: flex;
  align-items: center;

  gap: 1.8rem;
}

#main-section .section-title:before {
  content: "";
  display: block;
  width: 2.5rem;
  height: 2.5rem;
  border-radius: 50%;

  background: #0a31a8;
}

#main-section .section-text {
  font-weight: 800;
  font-size: 6.4rem;

  word-break: keep-all;

  line-height: 1.34;
  letter-spacing: -0.02em;
}

/* grid-right 오른쪽 부분 widget이 공간을 차지하는 부분을 다시 설장 */
#main
  .main-section-inner
  .main-container
  .grid-area
  .grid-right.sec1-exclusion
  .widgets {
  /* 공간을 동일하게 분배 */
  grid-template-columns: 1fr 1fr;
}

/* section2의 위젯을 다시 설정 */
#main .sec1-exclusion .widget {
  padding: 3rem;
  /* 배경색 전환 */
  background: #0b235b;
  /* backdrop-filter와 filter는 모두 CSS에서 요소에 그래픽 효과를 적용하는 속성이다. */
  /* 이 둘의 차이점은 backdrop-filter는 배경에만 효과를 적용하고, filter는 요소 전체에 효과를 적용한다는 점이다. */
  backdrop-filter: blur(60px);

  /* widget-top과 bottom의 간격  */
  gap: 6.4rem;
}

#main .sec1-exclusion .widget .widget-top {
  display: flex;
  flex-direction: column;
  gap: 1.2rem;
}

#main .sec1-exclusion .widget .widget-top .widget-top-title {
  /* 그게 아니라 gap이든 margin이든 a링크의 block요소를 주지 않으면 벌어지지 않음. */
  /*  margin-bottom: 1.2rem; */

  font-weight: 800;
  font-size: 3.2rem;
  color: #fff;

  line-height: 1.2;
}

#main .sec1-exclusion .widget .widget-top .widget-text {
  font-weight: 600;
  font-size: 1.7rem;

  color: #fff;
  opacity: 0.7;

  line-height: 1.4;

  word-break: keep-all;
}

#main .sec1-exclusion .widget .widget-top .widget-download-icon {
  display: flex;
  align-items: center;
}

/* padding을 이용한 크기  */
#main .sec1-exclusion .widget .widget-top .widget-download-icon a {
  display: inline-block;
  padding: 1.4rem 1.6rem;

  border-radius: 5.4rem;
  background: rgba(255, 255, 255, 0.16);

  font-weight: 800;
  font-size: 1.5rem;
  letter-spacing: -0.02em;

  display: flex;
  align-items: center;
  gap: 1rem;

  transition: 250ms ease-in-out;
  transition-property: background color;
}

#main .sec1-exclusion .widget .widget-top .widget-download-icon a::after {
  content: "";
  display: block;
  width: 1.4rem;
  height: 1.4rem;

  background: url(../img/download-btn.svg) no-repeat 0 0 / contain;

  transition: 250ms ease-in-out;
  transition-property: background;
}

#main .sec1-exclusion .widget .widget-top .widget-download-icon a:hover {
  background: #fff;
  color: #0a31a8;
}

#main .sec1-exclusion .widget .widget-top .widget-download-icon a:hover::after {
  background: url(../img/download-btn-hover.svg) no-repeat 0 0 / contain;
}

#main .sec1-exclusion .widget .widget-bottom {
  display: flex;
  justify-content: space-between;

  /* 바닥에 맞추려면 flex-end 이런식으로 설정 */
  /* vertical-align : baseline X flex 요소에는 flex-start, end, center, baseline, 등등 이런식으로 설정 */
  /* vertical-align :baseline이 안먹는 이유는 inline이나 inline-block요소에만 적용이 된다. */
  /* align-items : bottom도 올바른 설정이 아님.  */
  /* 요소에 크기가 달라서 높이가 다른 것 맞추려면 flex-end 등등 사용하면 맞춰짐 */
  align-items: flex-end;
}

#main .sec1-exclusion .widget .widget-bottom .widget-icon {
  display: flex;
  align-items: center;
}

#main .sec1-exclusion .widget .widget-bottom .widget-icon a {
  width: 4rem;
  height: 4rem;
  border-radius: 2rem;

  display: flex;
  align-items: center;
  justify-content: center;

  background: rgba(255, 255, 255, 0.16);
  transition: background 250ms ease-in-out;
}

#main .sec1-exclusion .widget .widget-bottom .widget-icon a:before {
  content: "";
  display: block;
  width: 1.4rem;
  height: 1.4rem;

  background: url(../img/widget-arrow.svg) no-repeat 0 0 / contain;

  transition: background 250ms ease-in-out;
}

#main .sec1-exclusion .widget .widget-bottom .widget-icon a:hover {
  background: #fff;
}

#main .sec1-exclusion .widget .widget-bottom .widget-icon a:hover:before {
  background: url(../img/widget-arrow-hover.svg) no-repeat 0 0 / contain;
}

/* 위젯마다 다른 이미지 기입 */
#main .sec1-exclusion .widget .widget-bottom .widget-img {
  display: inline-block;
  width: 12.4rem;
  height: 12.4rem;
}

#main .sec1-exclusion .widget.notice .widget-bottom .widget-img {
  background: url(../img/section2-widget-img1.png) no-repeat 0 0 / contain;
}

#main .sec1-exclusion .widget.estimation .widget-bottom .widget-img {
  background: url(../img/section2-widget-img2.png) no-repeat 0 0 / contain;
}

#main .sec1-exclusion .widget.initiative .widget-bottom .widget-img {
  background: url(../img/section2-widget-img3.png) no-repeat 0 0 / contain;
}

#main .sec1-exclusion .widget.contribution .widget-bottom .widget-img {
  background: url(../img/section2-widget-img4.png) no-repeat 0 0 / contain;
}

/*  section2 CSS - end */

/* section3 CSS - start */
.section3 {
  position: relative;

  width: 100%;
  z-index: 3;

  padding: 13rem 0 10rem 0;

  /* section3는 배경 컬러를 section3에 직접 적용 */
  background: #fff;
}

/* 텍스트 부분 */

.section3 .section3-title-con {
  display: flex;
  gap: 2.4rem;
  flex-direction: column;
}

#main .section3 .section-title {
  color: #000;
}

/* section3 card swiper 슬라이드 부분 */
.section3 .card-container {
  margin-top: 8rem;

  position: relative;
}

.section3 .card-container .card-slide {
  /* 떨어지지 않은 카드 디자인 */
  display: flex;
  align-items: center;
}

/* 카드 디자인 아이템 */
.section3 .slide-item {
  padding: 2.4rem 3.6rem;

  transition: 300ms ease-in-out;
  transition-property: background, color;

  border-radius: 2.4rem;

  display: flex;
  flex-direction: column;
}

.section3 .slide-item .item {
  width: 100%;
  height: 100%;

  display: block;
}

/* background에 scale이 안먹는다. */
/* 문제점 background-img가 크기를 벗어나서 틀어지는 것을 방지하기 위해 slide-img에 overflow : hidden을 줬는데도, 틀어지면서 확대되는 이유 */
/* 문제의 본질은 background-img는 transform : scale이 먹지 않아서 그렇다. -> transform은 요소 자체에 적용되는 CSS 속성이다. */
/* 지금 HTML에 구조에는 background의 이미지가 slide-img에 단순 배경으로 지정되어 있기 때문에 slide-img에 transform을 적용하면 slide-img 자체가 커지면서 이미지도 커지는 것이다. */
/* 그래서 결국 slide-img에 overflow : hidden이 있다고 해도 slide-img가 커지는 것이기 때문에 slide-item을 벗어나 레이아웃이 틀어질 수도 있게 된다. */
/* 이에 대한 해결방안은 확대대는 이미지를 별도 요소로 분리하여 사용하는 것이다. */
/* 즉 slide-img안에 자식 요소를 더 추가하여 감싸는 것이다.  <div class = ".ss"><div class =".img-inner"></div></div>*/
/* 또 다른 방법은 img태그를 이용하여 background가 아닌 HTML에 구조에 img태그를 사용하는 방법이다. */
/* 이 방법을 더 권장한다. 시멘틱, 접근성, 반응형 모두 대응 가능하기 때문에 -> 본페이지에서도 img태그를 사용하였음. */
/* .section3 .slide-item:hover .slide-img {
  transform: scale(1.1);
} */

.section3 .slide-item:hover {
  background: #1c56ff;

  color: #fff;
}

.section3 .slide-item .slide-img {
  width: 32rem;
  height: 21.3rem;

  border-radius: 1.4rem;

  overflow: hidden;
}

.section3 .slide-item .slide-img img {
  display: block;
  width: 100%;
  height: 100%;

  object-fit: cover;
  transition: transform 300ms ease-in-out;
}

/* img 태그를 넣어 이미지에 transform : scale 효과를 준다. HTMl 구조 변경. */

.section3 .slide-item:hover .slide-img img {
  transform: scale(1.1);
}

.section3 .slide-item .slide-title {
  margin-top: 2rem;
  display: flex;
  align-items: center;

  gap: 0.8rem;

  font-weight: 500;
  font-size: 1.4rem;
  letter-spacing: 0em;

  /* 대문자로 변환 */
  text-transform: uppercase;

  word-break: keep-all;
}

.section3 .slide-item .slide-title:before {
  content: "";
  display: block;
  width: 1.2rem;
  height: 1.2rem;

  border-radius: 50%;
  background: #0a31a8;
}

.section3 .slide-item .slide-text-con {
  margin-top: 1.6rem;

  display: flex;
  flex-direction: column;

  gap: 1.6rem;

  word-break: keep-all;
}

.section3 .slide-item .slide-text-con .slide-title2 {
  font-weight: 700;

  font-size: 2rem;

  line-height: 1.36;
  letter-spacing: -0.02em;
}

.section3 .slide-item .slide-text-con .slide-text {
  font-weight: 400;
  font-size: 1.6rem;

  line-height: 1.4;
  letter-spacing: -0.02em;
}

.section3 .slide-item .slide-arrow-btn {
  display: flex;
  align-items: center;

  justify-content: end;

  margin-top: 2.4rem;
}

.section3 .slide-item .slide-arrow-btn .arrow-btn {
  display: flex;
  align-items: center;
  justify-content: center;

  width: 4rem;
  height: 4rem;
  border-radius: 2rem;

  background: #f3f3f3;
}

.section3 .slide-item .slide-arrow-btn .arrow-btn:before {
  content: "";
  display: block;

  width: 1.4rem;
  height: 1.2rem;

  background: url(../img/slide-arrow-icon.svg) no-repeat 0 0 / cover;
}

/* section3 CSS - end */

/* section4 CSS - start */
.section4 {
  position: relative;

  width: 100%;

  /* 배경 컬러  */
  background: #1c56ff;

  min-height: 100svh;

  /* 나는 틀어지니까 최소 높이를 설정 1220px로 설정 */
  min-height: 122rem;

  overflow: hidden;
}

/* section4 - grid 설정 바꾸기 */
#main .section4 .main-section-inner .main-container .grid-area .grid-left {
  align-items: start;
}

#main .section4 .main-section-inner .grid-area .grid-left .grid-left-container {
  gap: 1.6rem;

  /* 텍스트 부분 최대크기 정해놓은 거 풀기 */
  max-width: none;
}

/* section4의 지구 이미지  */
.section4 .visual {
}
.section4 .visual .sec4-bg {
  width: 85.7rem;
  height: 85.7rem;

  background: url(../img/section4-earth.png) no-repeat 0 0 / cover;

  /* 가상요소로 만들기 */
  position: absolute;
  top: 25rem;
  left: 5.8rem;
}

/* section4 -> widget(위젯)디자인 바꾸기 */

/* grid의 열이 가지는 비율을 동일하게 */

#main .section4 .widget {
  padding: 3.2rem 4rem;

  gap: 2.2rem;
}

#main
  .section4
  .main-container
  .grid-area
  .grid-right
  .widgets
  .widget
  .widget-title {
  display: flex;
  flex-direction: column;
  align-items: start;

  gap: 1rem;

  font-size: 2.1rem;

  line-height: 1.2;
  letter-spacing: -0.02em;
  font-weight: 800;

  /* 한줄로 적용(줄바꿈 일어나지 않음) */
  white-space: nowrap;
}

#main
  .section4
  .main-container
  .grid-area
  .grid-right
  .widgets
  .widget
  .widget-title:before {
  display: block;
  width: 5rem;
  height: 5rem;

  border-radius: 0;
}

#main
  .section4
  .main-container
  .grid-area
  .grid-right
  .widgets
  .widget.cambodia
  .widget-title:before {
  background: url(../img/cambodia.png) no-repeat 0 0 / contain;
}

#main
  .section4
  .main-container
  .grid-area
  .grid-right
  .widgets
  .widget.myanmar
  .widget-title:before {
  background: url(../img/myanmar.png) no-repeat 0 0 / contain;
}

#main
  .section4
  .main-container
  .grid-area
  .grid-right
  .widgets
  .widget.vietnam
  .widget-title:before {
  background: url(../img/vietnam.png) no-repeat 0 0 / contain;
}

#main
  .section4
  .main-container
  .grid-area
  .grid-right
  .widgets
  .widget.korea
  .widget-title:before {
  background: url(../img/korea.png) no-repeat 0 0 / contain;
}

.section4 .widget-top {
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}

.section4 .widget-bottom {
}

.section4 .widget-bottom .bottom-title {
  font-size: 1.6rem;
  font-weight: 500;

  letter-spacing: -0.02em;
  line-height: 1.2;
}

.section4 .widget-bottom .branch-office {
  display: flex;
  flex-direction: column;

  gap: 2rem;

  margin-top: 2.4rem;
}

.section4 .widget-bottom .branch-office .branch-office-name {
  font-size: 1.5rem;
  font-weight: 600;

  letter-spacing: -0.02em;
  line-height: 1.2;

  display: flex;
  align-items: center;

  gap: 0.8rem;
}

/* branch-office-name 앞에 있는 숫자가 들어간 동그란 디자인은 가상요소로 들어가면 복잡하기 때문에 */
/* HTML 구조에 넣어 숫자만 집어넣고 동일한 디자인을 부여하는 게 더 좋을 거 같다. */
.section4 .widget-bottom .branch-office .branch-office-name .branch-num {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 3.2rem;
  height: 3.2rem;

  border-radius: 1.6rem;
  background: rgba(255, 255, 255, 0.3);

  font-weight: 800;
  font-size: 1.4rem;
  color: #fff;
}

/* section4의 위젯은 완쪽과 오른쪽의 크기와 높이가 다르다. 그러므로 HTML구조에 더 추가해야한다.  */
/* grid를 더 줄 요소를 만들어야 하므로 감싸야한다. -> 마니 헷갈린다.  */
/* col요소를 다 감싸줄 하나의 요소를 만들어야 한다. 그리고 col 각각 하나 더 감싸야한다. */
/* 그리고 col-left와 col-right 을 감싸줘야 한다. */
/* 이렇게 하면 위젯들이 세로로 한줄로 변경 */
/* 한줄로 변경되는 것처럼 보이는 것이지 2개의 열을 형성중이다. widgets 요소의 grid-template-colums 설정에 의해  col-left와 col-right이 수평으로 배치되었기 떄문에 전체적으로 한줄로 변경된 것처럼 보이는 것이다.   */

/* 감싼 요소를 바꾸기 위해서는 grid 설정을 바꿔야한다. 다시 설정. */
/* section4에서 grid-area에 있는 flex도 설정을 해제해줘야 widgets에 설정해줬던 max-width의 크기만큼 넓어진다. */
/* section4에서는 widgets에 있는 grid를 해제해야한다. -> 아예 새로운 class를 주어 했는데 나는 주어진 것에서 설정을 바꾸어서 하곘음. */

/* grid-right에 있던 flex를 제거하면 자동적으로 widget에 크기가 부모의 너비를 따라가게 된다. */
#main .section4 .main-container .grid-area .grid-right {
  display: block;
}

/* widgets에 grid와 grid-template-columns를 헤제하게 된다면 widget에 크기가 widgets에 있던 max-width의 크기에 따라가게 되고, 꼭 max-width만을 따라가는 게 아닌, 부모의 너비만큼 크기를 가지게된다. */
/* 그리고, grid가 설정되어 있어도, grid-template-columns만 설정를 해제해도 크기는 부모만큼 갖게 된다. 이유는 열로 나누지 않고 비율만큼 맞추지 않아도 되기 때문이다. */
#main .section4 .main-container .grid-area .grid-right .widgets {
  display: block;
}

/* 이렇게 되면 한줄로 변경이 되고, 부모만큼의 크기를 가지게 되서 반응형에 대응하기 쉬워진다.  */
/* 우리가 할 다지안은 다시 두줄로 만들어야 하기 때문에, 이렇게 widget이 넓이를 100%를 가지고 있을 때 grid를 다시 설정해서 2열로 만들고, 크기를 맞출 것이다. */
/* 그래서 col을 col-left와 col-right을 묶은 다음 공통 class (col-content)를 줘 같은 것을 적용하게 되게 만들고,*/
/* 공통 class인 col-content(col-left와 col-right)을 다시 한번 감싸서 부모 요소로 만든다. -> col-wrapper로 설정 */
/* 그리고 col-wrapper에 grid을 설정하게 되는 것이아. */
.section4 .widgets .col-wrapper {
  display: grid;

  grid-template-columns: 1fr 56%;
  /* grid-template-columns 설정하는데, 모르는 게 나옴 */
  /* repeat(2..) 2개의 열을 만든다는 것이다. -> 자식 요소가 2개라면 1,2만 보이지만 열은 생성된다. */
  /* minmax(0,.1fr)은 레이아웃이 틀어지는 것을 방지하기 위해 사용되는 CSS중 하나라거 한다. */
  /* minmax(최소값, 최대값)는 그리드이 셀의 너비나 높이를 최소 min에서 최대 max 사이로 제한 */
  /* minmax(0,1fr)는 최소 너비 0px -> 완전히 줄어들 수 있음. ,최대 너비는 남은 공간에서 1fr만큼 늘릴 수 있다는 뜻이다. */
  /* 1fr 1fr처럼 fr만 사용하게 된다면, 콘텐츠에 크기에 따라 열이 넘칠 수 있기 때문에 이를 방지하기 위해서 minmax(0,1fr)을 사용하게 된 것이다. */
  /* 0아니면 숫자를 넣고 px를 넣어주면 된다. 넓이 단위 */
  /* 그러니 repeat()과 minmax()를 사용하는 경우는 주로 CSS Grid 레이아웃을 적용할 때 , 특히 반응형 웹디자인을 구현할 때 유용하다.*/
  grid-template-columns: repeat(2, minmax(0, 1fr));

  /* col-left와 col-right 간격 두기 */
  gap: 1.6rem;

  align-items: center;
}

/* section4 CSS - end */

/* section5 CSS - start */
#main .section5 .main-container .grid-area .grid-left {
  align-items: start;
}

#main .section5 .main-container .grid-area .grid-left .grid-left-container {
  gap: 1.6rem;
}

#main .section5 .section-title,
#main .section5 .section-text {
  font-weight: 700;
  color: #333;
}

.section5 {
  position: relative;
  width: 100%;
  z-index: 4;

  min-height: 136.2rem;

  background-color: #fff;
}

/* 텍스트 틀어지는 것을 막기 위함. */
#main .section5 .main-container .grid-area .grid-left .grid-left-container {
  max-width: none;
}

/* grid-right에 flex를 풀어주고 align-items를 적용안되게 block으로 설정해준다. */
#main .section5 .main-container .grid-area .grid-right {
  display: block;
}

/* section5 그리드는 또 본페이지와 완전히 다르다.  */
/* 본페이지는 grid를 적용할 아이템들이 4개, 즉 col에 들어간 2개 요소가 다 풀어지고 col에 있는 것도 다 없애고 col에 있는 요소들을 items로 하나로 묶었다. */
/* 그러므로 widgets에 설정되어있던 grid를 설정을 해제하고 widget를 하나로 묶어둔 widget-news-items에 grid를 설정해야함. */
#main .section5 .main-container .grid-area .grid-right .widgets {
  display: block;
  /* block으로 설정하면 widget들이 한줄로 변경 */

  /* max-width 설정 없애기 -> widget의 크기를 위해서. */
  max-width: none;
}

.section5 .widgets .widget-news-items {
  display: grid;
  gap: 1.6rem;

  /* 2개의 열을 만들고, 가용 공간을 1:1 비율로 나눈다. -> 가로를 2개를 똑같이 만들고 싶을 때 가장 안전한 설정 */
  grid-template-columns: repeat(2, minmax(0, 1fr));

  /* 1오와 2오의 차이 */
  row-gap: 6.4rem;
}

#main .section5 .widget {
  padding: 0;
  color: #333;

  /* 보더 맞추기 */
  border-radius: 0;

  /* 배경 컬러 바꿔주기 */
  background: #fff;
}

#main .section5 .widget .widget-img {
  border-radius: 2.4rem;
  /* border-radius가 overflow : hidden이 없이는 적용되지 않는다. */
  overflow: hidden;

  margin-bottom: 2.4rem;
}

/* widget news 부분에 hover 했을 때 이미지 scale() -> css background로 들어가면 틀어짐 */
#main .section5 .widget a:hover .widget-img img {
  transform: scale(1.1);
}

#main .section5 .widget .widget-img img {
  display: block;
  /* width : 100%로 하면 부모요소에게 딱 맞게 들어온다. */
  /* 이유는 img의 기본 너비는 intrinsic(고유 너비) 아무 스타일도 적용하지 않으면 <img>는 자기 원본 이미지의 해상도만큼 너비를 가지게 됩니다. */
  /* 그래서 width : 100%을 주게 된다면 부모 요소에게 딱 알맞게 적용되는 것이죠. */
  width: 100%;
  object-fit: cover;

  transition: transform 250ms ease-in-out;
}

.section5 .news-title {
  font-weight: 700;

  letter-spacing: 0.002em;
  line-height: 2.9rem;

  font-size: 2.1rem;
  margin-bottom: 1.6rem;

  /* 텍스트 부분  -> 모르는 부분 */
  word-break: keep-all;

  /* 넘치는 텍스트를 숨김 처리, 줄 수 제한할 때 반드시 필요함 */
  overflow: hidden;

  /* 줄 수 제한을 위해 반드시 필요 -> flexbox와는 다른, 구형 레이아웃 시스템 */
  display: -webkit-box;

  /* 정확히 2줄까지만 보여주고, 그 이상은 잘라버린다. */
  /* 이것만 사용하는 게 아니라, display: -webkit-box; ,  -webkit-box-orient: vertical; , overflow: hidden; 이 세가지를 함께 사용해야한다.*/
  -webkit-line-clamp: 2;

  /* 수직 방향 박스로 정렬 */
  -webkit-box-orient: vertical;

  /* 이것은 CSS 최신 속성 -> 텍스트 줄바꿈을 '보기 좋게' 정리해줌 -> 의미 단위 (어절)을 꺠지 않고 자연스럽게 줄바꿈 */
  text-wrap: pretty;
}

.section5 .news-data {
  display: block;
  font-size: 1.5rem;
  font-weight: 500;

  line-height: 1.6;

  color: #666;

  letter-spacing: 0;
}
/* section5 CSS - end */

/* section6 CSS - start */
.section6 {
  position: relative;

  z-index: 1;

  width: 100%;
}

/* #main .visual에 들어간 position : relative를 없애줘야 background의 이미지가 보인다.  */
#main .section6 .visual {
  position: static;
}

.section6 .visual .visual-bg {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;

  background: url(../img/section6-bg.png) no-repeat 50% 50% / cover;
}

.section6 .visual .visual-bg:before {
  content: "";
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;

  background: rgba(0, 0, 0, 0.2);
}

/* section6는 다른 섹션에 비해 높이가 다르기 때문에 grid-left에 있는 height를 없애고 grid-area에 padding이 남아있는 것으로 높이를 얼추 맞추겠다. */
/* grid-area는 grid가 되어있는 부분으로 두개의 자식 (grid-left, grid-right)이 자식으로 있다. */
#main .section6 .main-container .grid-area .grid-left {
  height: auto;
}

/* 그리고 또 크기가 어쩔 수 없이 형성된 grid-left-container에도 max-width를 없애주고 텍스트를 두줄로 변경시킨다. -> 그러면 크기가 더 줄어든다. */
#main .section6 .main-container .grid-area .grid-left .grid-left-container {
  max-width: none;

  gap: 1.6rem;
}

#main .section6 .section-text {
  line-height: 1.48;

  font-weight: 700;
  letter-spacing: -0.04em;
}

/* grid-right에서 widget들은 지금 grid로 설정되어있다. widget 부모는 col인데 서로 다른 열로 설정되어있다. grid-template-columns로 인해서  */
/* 그렇기 때문에 col의 부모요소인 widgets에게 grid-template-columns가 설정되어 있다는 것이다. *
/* 그걸 동일한 비율로 나타나게 해야한다. */
#main .section6 .main-container .grid-area .grid-right .widgets {
  /* 이렇게 설정하면 두개의 열이 동일한 비율을 가지게된다. */
  grid-template-columns: repeat(2, minmax(0, 1fr));

  /* widgets가 가지고 있는 max-width의 크기를 늘리면 col에 있는 widget들이 크기를 늘릴 수 있을만큼 늘린다. 그러고 나서 늘릴 수 없으면 max-width의 크기를 아무리 늘려도 늘어나지 않는다. */
  /* 그렇기에 max-width을 없애주고 크기를 늘린다. -> 왜 max-width을 없애면 크기가 늘어나냐면 최대 넓이를 조정해뒀기 떄문에 늘어나고 싶어도 늘어나지 못하는 widget이 max-width가 사라지면 자신의 크기만큼 늘린댜. */
  max-width: none;
}

#main .section6 .main-section-inner .main-container .grid-area .grid-right {
  /* flex를 지웠을 때 왜 크기가 늘어나나 햿더니 grid-right과 widget의 크기가 달랐기 떄문이다. */
  /* widgets은 grid로 설정되어 있고, max-width가 설정되어있었는데 max-width를 지우고 나서 크기가 늘어난 이유는 최대 크기의 제약을 지웠기 때문에  */
  /* widgets의 크기만큼만 widget들이 늘어났고, grid-right에 flex를 지웠더니 widget의 크기가 더 커진 이유는 */
  /* widgets는 grid-right의 flex박스 크기보다 작았고, 그래서 그 안에서 margin-left : auto등 이런 명령에 자유롭게 움직임이 보였던 것이다.  */
  /* 그래서 grid-right에 flex설정을 없앴다면 widgets의 크기는 flex로 인해 크기가 제약되던 것이 풀려 grid-right에 크기만큼 widgets가 커져서 widget들도 같이 느는 것이다. */
  /* 내가 보기엔 그런 것 같다. */
  display: block;
}

/* section6의 widget들은 서로 다른 열로 하나씩 이기 때문에 col에 gap명령은 필요가 없다. */
#main .section6 .main-container .grid-area .grid-right .widgets .col {
  gap: inherit;
}

/* section에 widget의 디자인은 배경이 흰색이다. */
#main .section6 .widget {
  background: #fff;
}

#main
  .section6
  .main-container
  .grid-area
  .grid-right
  .widgets
  .widget
  .widget-title {
  color: #000;
  font-size: 3.6rem;
  font-weight: 600;
}

/* 가상요소 없애기 */
#main
  .section6
  .main-container
  .grid-area
  .grid-right
  .widgets
  .widget
  .widget-title:before {
  display: none;
}

.section6 .widget-text {
  color: #666;
  font-size: 1.8rem;

  line-height: 1.4;

  word-break: keep-all;

  letter-spacing: -0.04em;

  margin-bottom: 6.4rem;
}

.section6 .widget-bottom {
}
.section6 .widget-bottom .widget-arrow-btn {
  display: flex;
  align-items: center;
  justify-content: end;
}

.section6 .widget-bottom .widget-arrow-btn button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 5rem;
  height: 5rem;

  border-radius: 2.5rem;

  background: #f3f3f3;

  transition: 250ms ease-in-out;
}

.section6 .widget:hover .widget-bottom .widget-arrow-btn button {
  background: #0a31a8;
}

.section6 .widget-bottom .widget-arrow-btn button:before {
  content: "";
  display: block;
  width: 2rem;
  height: 1.8rem;

  background: url(../img/section-arrow.svg) no-repeat 0 0 / contain;

  transition: background 250ms ease-in-out;
}

.section6 .widget:hover .widget-bottom .widget-arrow-btn button:before {
  display: block;
  width: 2rem;
  height: 1.8rem;

  background: url(../img/slide-arrow-hover-icon.svg) no-repeat 0 0 / contain;
}

/* section6 위젯 디자인 */
#main .section6 .widget {
  padding: 4rem 3.2rem;

  /* 최소 높이를 설정해 위젯의 크기가 더 작아지지 않게 고정 */
  min-height: 29.6rem;
}

/* 본페이지에서는 grid-right부분의 col를 하나로 묶고 그 부모에게 flex로 설정하고,  자식에게는 flex : 1를 주는 형식으로 했음.  */
/* 그렇게 하면 부모의 크기를 다 얻고, 반응형 웹 디자인에 좋을 것으로 판단된다.  */

/* section6 CSS - end */

/* footer CSS - start */
#footer {
  position: relative;
  z-index: 3;

  background: #0a31a8;

  padding: 4.8rem 0;
}

#footer .footer-inner {
  width: 100%;
  max-width: 179.2rem;

  background: gray;

  margin: 0 auto;
}

#footer .footer-top {
  display: flex;

  justify-content: space-between;

  margin-bottom: 6rem;
}

#footer .footer-top .footer-logo-box {
  display: block;
  width: 21.2rem;
  height: 3.4rem;

  background: url(../img/brand-logo.png) no-repeat 0 0 / contain;
}

#footer .footer-top .footer-logo-box a {
  display: block;
  width: 100%;
  height: 100%;
}

#footer .footer-top .family-site {
  display: block;
  width: 28rem;
  height: 5.4rem;

  border-radius: 2.7rem;

  background: rgba(255, 255, 255, 0.4);
  color: #fff;
  transition: 150ms ease-in-out;
}

#footer .footer-top .family-site .link-site {
  display: flex;
  align-items: center;

  gap: 0.8rem;

  padding: 0 2.8rem;

  width: 100%;
  height: 100%;

  font-weight: 700;
  font-size: 1.6rem;

  line-height: 1.34;
}

#footer .footer-top .family-site:hover {
  color: #000;
  background: #fff;
}

#footer .footer-top .family-site .link-site::before {
  content: "";
  display: block;
  width: 1rem;
  height: 1rem;

  border-radius: 50%;
  background: #fff;

  transition: 150ms ease-in-out;
}

#footer .footer-top .family-site:hover .link-site::before {
  background: #0a31a8;
}

.family-site-menu {
  display: none;
}

/* footer bottom */
#footer .footer-bottom {
  display: flex;
  justify-content: space-between;

  align-items: flex-end;
}

#footer .footer-bottom .footer-bottom-con {
}

#footer .footer-bottom .footer-bottom-con .copy-right-content {
  font-weight: 600;
  font-size: 1.6rem;

  line-height: 1.35;
  color: rgba(255, 255, 255, 0.8);
}

.copy-right-content .copy-right {
  margin-left: 1.8rem;
}

#footer .footer-bottom .footer-bottom-con .footer-link {
  margin-top: 1.2rem;
  display: flex;
  align-items: center;
  gap: 1.8rem;
}

.footer-link .link-icon a {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 3.6rem;
  height: 3.6rem;

  border-radius: 50%;
  background: rgba(255, 255, 255, 0.5);

  transition: background 150ms ease-in;
}

.footer-link .link-icon a:hover {
  background: #fff;
}

.footer-link .link-icon a:before {
  content: "";
  display: block;

  transition: background 150ms ease-in;
}

.footer-link .instagram a:hover:before {
  background: url(../img/footer-link1-hover.png) no-repeat 0 0 / contain;
}

.footer-link .youtube a:hover:before {
  background: url(../img/footer-link2-hover.png) no-repeat 0 0 / contain;
}

.footer-link .naver-blog a:hover:before {
  background: url(../img/footer-link3-hover.svg) no-repeat 0 0 / contain;
}

.footer-link .instagram a:before {
  width: 2rem;
  height: 2rem;

  background: url(../img/footer-link1.png) no-repeat 0 0 / contain;
}

.footer-link .youtube a:before {
  width: 2.1rem;
  height: 1.6rem;

  background: url(../img/footer-link2.png) no-repeat 0 0 / contain;
}

.footer-link .naver-blog a:before {
  width: 2.2rem;
  height: 1.8rem;

  background: url(../img/footer-link3.svg) no-repeat 0 0 / contain;
}

.copy-right-content .footer-information {
  display: flex;
  align-items: center;
}

.copy-right-content .footer-information span {
  margin-right: 1.6rem;

  display: flex;
  align-items: center;
  gap: 1.8rem;
}

.copy-right-content .footer-information span:after {
  content: "";
  display: inline-block;
  width: 1px;
  height: 14px;

  background: rgba(255, 255, 255, 0.2);
}

.copy-right-content .footer-information span:last-child:after {
  display: none;
}

.copy-right-content .footer-information span:last-child {
  margin-right: 0;
}

.copy-right-content .bold {
  color: #fff;
}

.footer-top-btn-box {
  color: rgba(255, 255, 255, 1);

  display: flex;

  position: relative;
}

.footer-top-btn-box .top-btn {
  display: flex;
  align-items: center;

  gap: 1.2rem;
}

.footer-top-btn-box .top-btn span {
  font-size: 1.6rem;
  font-weight: 600;
}

.top-btn .top-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 4rem;
  height: 4rem;
  border-radius: 50%;

  background: rgba(255, 255, 255, 0.5);

  transition: background 150ms ease-in-out;
}

.top-btn:hover .top-icon {
  background: #fff;
}

.top-btn .top-icon:before {
  content: "";
  display: block;
  width: 1rem;
  height: 1.4rem;

  background: url(../img/footer-arrow.svg) no-repeat 50% 50% / contain;

  transition: background 150ms ease-in-out;
}

.top-btn:hover .top-icon:before {
  background: url(../img/footer-arrow-hoer.svg) no-repeat 50% 50% / contain;
}

/* footer CSS - end */
